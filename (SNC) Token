// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IUniswapV2Router02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;

    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

contract Syncoin is ERC20, ERC20Snapshot, Ownable, ReentrancyGuard {
    // Governance proposal structure
    struct Proposal {
        bytes32 descriptionHash;
        uint256 voteCountFor;
        uint256 voteCountAgainst;
        uint256 deadline;
        bool executed;
        uint256 snapshotId; // Snapshot ID for governance voting
    }

    Proposal[] public proposals;
    mapping(uint256 => mapping(address => bool)) public hasVoted;

    event ProposalCreated(uint256 proposalId, bytes32 descriptionHash, uint256 deadline);
    event Voted(uint256 proposalId, address voter, bool voteFor, uint256 votePower);
    event ProposalExecuted(uint256 proposalId, bool success);

    // Token properties
    uint256 public _buyTaxFee = 1;
    uint256 public _sellTaxFee = 1;
    uint8 private constant _decimals = 18;
    uint256 private constant _tTotal = 1618033 * 10 ** _decimals;
    uint256 public _taxSwapThreshold = 3000 * 10 ** _decimals;
    uint256 public _maxWalletHoldingLimit = 16180 * 10 ** _decimals;
    uint256 public _maxSwapAmount = 5000 * 10 ** _decimals;

    address payable public _taxCollector = payable(0xB685E32702D7c3D5c3C03B81224B8f121E5514db);

    mapping(address => bool) private _isExcludedFromFee;
    mapping(address => uint256) private _balances;

    IUniswapV2Router02 private uniswapV2Router;
    address private uniswapV2Pair;
    bool private inSwap = false;
    bool private swapEnabled = true;

    modifier lockTheSwap {
        inSwap = true;
        _;
        inSwap = false;
    }

    constructor() ERC20("Syncoin", "SNC") {
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;

        _mint(_msgSender(), _tTotal);
    }

    function name() public pure returns (string memory) {
        return "Syncoin";
    }

    function symbol() public pure returns (string memory) {
        return "SNC";
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function _transfer(address from, address to, uint256 amount) internal override nonReentrant {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");

        uint256 taxAmount = 0;
        if (!_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {
            if (to != uniswapV2Pair) {
                require(balanceOf(to) + amount <= _maxWalletHoldingLimit, "Exceeds max wallet limit");
            }

            if (from == uniswapV2Pair) {
                taxAmount = amount * _buyTaxFee / 100;
            } else if (to == uniswapV2Pair) {
                taxAmount = amount * _sellTaxFee / 100;
            }

            if (!inSwap && to == uniswapV2Pair && swapEnabled) {
                uint256 contractTokenBalance = balanceOf(address(this));
                uint256 swapAmount = contractTokenBalance > _maxSwapAmount ? _maxSwapAmount : contractTokenBalance;

                if (swapAmount >= _taxSwapThreshold) {
                    swapTokensForEth(swapAmount);
                    uint256 contractETHBalance = address(this).balance;
                    if (contractETHBalance > 0) {
                        sendETHToFee(contractETHBalance);
                    }
                }
            }
        }

        if (taxAmount > 0) {
            _balances[address(this)] += taxAmount;
            emit Transfer(from, address(this), taxAmount);
        }

        _balances[from] -= amount;
        _balances[to] += amount - taxAmount;
        emit Transfer(from, to, amount - taxAmount);
    }

    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
        if (tokenAmount == 0) return;

        // Declare the path as an array of addresses
        address;
        path[0] = address(this); // Token address (this contract)
        path[1] = uniswapV2Router.WETH(); // WETH address

        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0, // Accept any amount of ETH
            path,
            address(this),
            block.timestamp
        );
    }

    function sendETHToFee(uint256 amount) private {
        (bool callSuccess, ) = _taxCollector.call{value: amount}("");
        require(callSuccess, "Failed to send ETH to tax collector");
    }

    // DAO governance functions

    function createProposal(bytes32 descriptionHash) public onlyOwner {
        uint256 deadline = block.timestamp + 3 days;
        uint256 snapshotId = _snapshot(); // Take a snapshot of all token holders' balances

        proposals.push(Proposal({
            descriptionHash: descriptionHash,
            voteCountFor: 0,
            voteCountAgainst: 0,
            deadline: deadline,
            executed: false,
            snapshotId: snapshotId
        }));

        emit ProposalCreated(proposals.length - 1, descriptionHash, deadline);
    }

    function vote(uint256 proposalId, bool voteFor) public {
        require(proposalId < proposals.length, "Proposal does not exist");
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp <= proposal.deadline, "Voting period is over");
        require(!hasVoted[proposalId][msg.sender], "You have already voted");

        uint256 votePower = balanceOfAt(msg.sender, proposal.snapshotId); // Use the snapshot balance
        require(votePower > 0, "You have no voting power");

        if (voteFor) {
            proposal.voteCountFor += votePower;
        } else {
            proposal.voteCountAgainst += votePower;
        }

        hasVoted[proposalId][msg.sender] = true;
        emit Voted(proposalId, msg.sender, voteFor, votePower);
    }

    function submitSnapshotResults(uint256 proposalId, uint256 voteCountFor, uint256 voteCountAgainst) public onlyOwner {
        require(proposalId < proposals.length, "Proposal does not exist");
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp > proposal.deadline, "Voting period has not ended");
        require(!proposal.executed, "Proposal already executed");

        proposal.voteCountFor = voteCountFor;
        proposal.voteCountAgainst = voteCountAgainst;

        if (voteCountFor > voteCountAgainst) {
            proposal.executed = true;
            emit ProposalExecuted(proposalId, true);
        } else {
            proposal.executed = false;
            emit ProposalExecuted(proposalId, false);
        }
    }

    receive() external payable {}
}

