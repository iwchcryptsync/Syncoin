// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IUniswapV2Router02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;

    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

contract Syncoin is Context, IERC20, Ownable {
    struct Proposal {
        bytes32 descriptionHash;
        uint256 voteCountFor;
        uint256 voteCountAgainst;
        uint256 deadline;
        bool executed;
        uint256 snapshotId;
    }

    Proposal[] public proposals;
    mapping(uint256 => mapping(address => bool)) public hasVoted;

    event ProposalCreated(uint256 proposalId, bytes32 descriptionHash, uint256 deadline);
    event Voted(uint256 proposalId, address voter, bool voteFor, uint256 votePower);
    event ProposalExecuted(uint256 proposalId, bool success);

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => bool) public _isExcludedFromFee;

    uint8 private constant _decimals = 18;
    uint256 private constant _tTotal = 1618033 * 10 ** _decimals;
    string private constant _name = unicode"Syncoin";
    string private constant _symbol = unicode"SNC";
    uint256 public _taxSwapThreshold = 3000 * 10 ** _decimals;
    uint256 public _maxWalletHoldingLimit = 16180 * 10 ** _decimals;
    uint256 public _maxSwapAmount = 5000 * 10 ** _decimals;
    uint256 public _buyTaxFee = 1; 
    uint256 public _sellTaxFee = 1; 

    address payable public _taxCollector = payable(0xB685E32702D7c3D5c3C03B81224B8f121E5514db);

    IUniswapV2Router02 private uniswapV2Router;
    address private uniswapV2Pair;
    bool private inSwap = false;
    bool private swapEnabled = true;
    uint256 private _status;

    // Reentrancy protection
    modifier nonReentrant() {
        require(_status != 1, "Reentrant call");
        _status = 1;
        _;
        _status = 0;
    }

    modifier lockTheSwap {
        inSwap = true;
        _;
        inSwap = false;
    }

    // Track all token holders
    address[] private _allTokenHolders;
    mapping(address => bool) private _isHolder;

    constructor() {
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;

        _balances[_msgSender()] = _tTotal;
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[address(this)] = true;
        _isExcludedFromFee[_taxCollector] = true;

        _allTokenHolders.push(_msgSender());
        _isHolder[_msgSender()] = true;

        emit Transfer(address(0), _msgSender(), _tTotal);
    }

    // --- ERC20 standard functions ---
    function name() public pure returns (string memory) {
        return _name;
    }

    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function totalSupply() public pure override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    // --- Transfer and Tax Logic ---
    function _transfer(address from, address to, uint256 amount) private nonReentrant {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");

        uint256 taxAmount = 0;

        // Consolidate redundant state changes
        uint256 fromBalance = _balances[from];
        uint256 toBalance = _balances[to];

        if (!_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {
            if (to != uniswapV2Pair) {
                require(toBalance + amount <= _maxWalletHoldingLimit, "Exceeds max wallet limit");
            }

            if (from == uniswapV2Pair) {
                taxAmount = (amount * _buyTaxFee) / 100;
            } else if (to == uniswapV2Pair) {
                taxAmount = (amount * _sellTaxFee) / 100;
            }

            if (!inSwap && to == uniswapV2Pair && swapEnabled) {
                // Add a check for contract's state before executing Uniswap interactions
                require(address(this).balance > 0, "Contract balance is zero");

                uint256 contractTokenBalance = balanceOf(address(this));
                uint256 swapAmount = contractTokenBalance > _maxSwapAmount ? _maxSwapAmount : contractTokenBalance;

                if (swapAmount >= _taxSwapThreshold) {
                    swapTokensForEth(swapAmount);
                    uint256 contractETHBalance = address(this).balance;
                    if (contractETHBalance > 0) {
                        sendETHToFee(contractETHBalance);
                    }
                }
            }
        }

        _balances[from] = fromBalance - amount;
        _balances[to] = toBalance + (amount - taxAmount);

        // Track token holders
        if (_balances[to] > 0 && !_isHolder[to]) {
            _allTokenHolders.push(to);
            _isHolder[to] = true;
        }

        if (_balances[from] == 0 && _isHolder[from]) {
            _removeHolder(from);
        }

        if (taxAmount > 0) {
            _balances[address(this)] += taxAmount;
            emit Transfer(from, address(this), taxAmount);
        }

        emit Transfer(from, to, amount - taxAmount);
    }

    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
        if (tokenAmount == 0) return;
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();

        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function sendETHToFee(uint256 amount) private {
        (bool callSuccess, ) = _taxCollector.call{value: amount}("");
        require(callSuccess, "Failed to send ETH to tax collector");
    }

    // --- DAO governance functions with Snapshot functionality ---
    function createProposal(bytes32 descriptionHash) public onlyOwner nonReentrant {
        uint256 deadline = block.timestamp + 3 days;
        uint256 snapshotId = _takeSnapshot();

        proposals.push(Proposal({
            descriptionHash: descriptionHash,
            voteCountFor: 0,
            voteCountAgainst: 0,
            deadline: deadline,
            executed: false,
            snapshotId: snapshotId
        }));

        emit ProposalCreated(proposals.length - 1, descriptionHash, deadline);
    }

    function vote(uint256 proposalId, bool voteFor) public nonReentrant {
        require(proposalId < proposals.length, "Proposal does not exist");
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp <= proposal.deadline, "Voting period is over");
        require(!hasVoted[proposalId][_msgSender()], "You have already voted");

        uint256 votePower = _snapshotBalanceOf(_msgSender(), proposal.snapshotId);
        require(votePower > 0, "You have no voting power");

        if (voteFor) {
            proposal.voteCountFor += votePower;
        } else {
            proposal.voteCountAgainst += votePower;
        }

        hasVoted[proposalId][_msgSender()] = true;
        emit Voted(proposalId, _msgSender(), voteFor, votePower);
    }

    function submitSnapshotResults(uint256 proposalId, uint256 voteCountFor, uint256 voteCountAgainst) public onlyOwner nonReentrant {
        require(proposalId < proposals.length, "Proposal does not exist");
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp > proposal.deadline, "Voting period has not ended");
        require(!proposal.executed, "Proposal already executed");

        proposal.voteCountFor = voteCountFor;
        proposal.voteCountAgainst = voteCountAgainst;

        if (voteCountFor > voteCountAgainst) {
            proposal.executed = true;
            emit ProposalExecuted(proposalId, true);
        } else {
            proposal.executed = false;
            emit ProposalExecuted(proposalId, false);
        }
    }

    // --- Snapshot Optimization: Batch Snapshots ---
    mapping(uint256 => mapping(address => uint256)) private _snapshotBalances;
    uint256 private _currentSnapshotId;

    function _takeSnapshot() internal returns (uint256) {
        _currentSnapshotId++;

        uint256 batchSize = 100; // Define a batch size to avoid gas limit issues
        for (uint256 i = 0; i < _allTokenHolders.length; i += batchSize) {
            for (uint256 j = i; j < i + batchSize && j < _allTokenHolders.length; j++) {
                address account = _allTokenHolders[j];
                _snapshotBalances[_currentSnapshotId][account] = _balances[account];
            }
        }

        return _currentSnapshotId;
    }

    function _snapshotBalanceOf(address account, uint256 snapshotId) internal view returns (uint256) {
        return _snapshotBalances[snapshotId][account];
    }

    function _removeHolder(address holder) private {
        _isHolder[holder] = false;
        for (uint256 i = 0; i < _allTokenHolders.length; i++) {
            if (_allTokenHolders[i] == holder) {
                _allTokenHolders[i] = _allTokenHolders[_allTokenHolders.length - 1];
                _allTokenHolders.pop();
                break;
            }
        }
    }

    // Fallback function to safely reject unintended transactions
    fallback() external payable {
        revert("Unintended transaction");
    }

    receive() external payable {}
}
